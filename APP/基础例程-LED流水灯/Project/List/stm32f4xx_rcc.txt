; generated by ARM C/C++ Compiler, 4.1 [Build 567]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\Obj\stm32f4xx_rcc.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\Obj\stm32f4xx_rcc.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\User -I..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F40XX --omf_browse=.\Obj\stm32f4xx_rcc.crf ..\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_rcc.c]
                          THUMB

                          AREA ||i.RCC_AHB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB1PeriphClockCmd PROC
;;;1459     */
;;;1460   void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
000000  4a06              LDR      r2,|L1.28|
;;;1461   {
;;;1462     /* Check the parameters */
;;;1463     assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));
;;;1464   
;;;1465     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1466     if (NewState != DISABLE)
000002  b129              CBZ      r1,|L1.16|
;;;1467     {
;;;1468       RCC->AHB1ENR |= RCC_AHB1Periph;
000004  f8d21830          LDR      r1,[r2,#0x830]
000008  4301              ORRS     r1,r1,r0
00000a  f8c21830          STR      r1,[r2,#0x830]
;;;1469     }
;;;1470     else
;;;1471     {
;;;1472       RCC->AHB1ENR &= ~RCC_AHB1Periph;
;;;1473     }
;;;1474   }
00000e  4770              BX       lr
                  |L1.16|
000010  f8d21830          LDR      r1,[r2,#0x830]        ;1472
000014  4381              BICS     r1,r1,r0              ;1472
000016  f8c21830          STR      r1,[r2,#0x830]        ;1472
00001a  4770              BX       lr
;;;1475   
                          ENDP

                  |L1.28|
                          DCD      0x40023000

                          AREA ||i.RCC_AHB1PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB1PeriphClockLPModeCmd PROC
;;;1851     */
;;;1852   void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
000000  4a06              LDR      r2,|L2.28|
;;;1853   {
;;;1854     /* Check the parameters */
;;;1855     assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
;;;1856     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1857     if (NewState != DISABLE)
000002  b129              CBZ      r1,|L2.16|
;;;1858     {
;;;1859       RCC->AHB1LPENR |= RCC_AHB1Periph;
000004  f8d21850          LDR      r1,[r2,#0x850]
000008  4301              ORRS     r1,r1,r0
00000a  f8c21850          STR      r1,[r2,#0x850]
;;;1860     }
;;;1861     else
;;;1862     {
;;;1863       RCC->AHB1LPENR &= ~RCC_AHB1Periph;
;;;1864     }
;;;1865   }
00000e  4770              BX       lr
                  |L2.16|
000010  f8d21850          LDR      r1,[r2,#0x850]        ;1863
000014  4381              BICS     r1,r1,r0              ;1863
000016  f8c21850          STR      r1,[r2,#0x850]        ;1863
00001a  4770              BX       lr
;;;1866   
                          ENDP

                  |L2.28|
                          DCD      0x40023000

                          AREA ||i.RCC_AHB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB1PeriphResetCmd PROC
;;;1658     */
;;;1659   void RCC_AHB1PeriphResetCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
000000  4a06              LDR      r2,|L3.28|
;;;1660   {
;;;1661     /* Check the parameters */
;;;1662     assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
;;;1663     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1664   
;;;1665     if (NewState != DISABLE)
000002  b129              CBZ      r1,|L3.16|
;;;1666     {
;;;1667       RCC->AHB1RSTR |= RCC_AHB1Periph;
000004  f8d21810          LDR      r1,[r2,#0x810]
000008  4301              ORRS     r1,r1,r0
00000a  f8c21810          STR      r1,[r2,#0x810]
;;;1668     }
;;;1669     else
;;;1670     {
;;;1671       RCC->AHB1RSTR &= ~RCC_AHB1Periph;
;;;1672     }
;;;1673   }
00000e  4770              BX       lr
                  |L3.16|
000010  f8d21810          LDR      r1,[r2,#0x810]        ;1671
000014  4381              BICS     r1,r1,r0              ;1671
000016  f8c21810          STR      r1,[r2,#0x810]        ;1671
00001a  4770              BX       lr
;;;1674   
                          ENDP

                  |L3.28|
                          DCD      0x40023000

                          AREA ||i.RCC_AHB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB2PeriphClockCmd PROC
;;;1491     */
;;;1492   void RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
000000  4a06              LDR      r2,|L4.28|
;;;1493   {
;;;1494     /* Check the parameters */
;;;1495     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;1496     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1497   
;;;1498     if (NewState != DISABLE)
000002  b129              CBZ      r1,|L4.16|
;;;1499     {
;;;1500       RCC->AHB2ENR |= RCC_AHB2Periph;
000004  f8d21834          LDR      r1,[r2,#0x834]
000008  4301              ORRS     r1,r1,r0
00000a  f8c21834          STR      r1,[r2,#0x834]
;;;1501     }
;;;1502     else
;;;1503     {
;;;1504       RCC->AHB2ENR &= ~RCC_AHB2Periph;
;;;1505     }
;;;1506   }
00000e  4770              BX       lr
                  |L4.16|
000010  f8d21834          LDR      r1,[r2,#0x834]        ;1504
000014  4381              BICS     r1,r1,r0              ;1504
000016  f8c21834          STR      r1,[r2,#0x834]        ;1504
00001a  4770              BX       lr
;;;1507   
                          ENDP

                  |L4.28|
                          DCD      0x40023000

                          AREA ||i.RCC_AHB2PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB2PeriphClockLPModeCmd PROC
;;;1883     */
;;;1884   void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
000000  4a06              LDR      r2,|L5.28|
;;;1885   {
;;;1886     /* Check the parameters */
;;;1887     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;1888     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1889     if (NewState != DISABLE)
000002  b129              CBZ      r1,|L5.16|
;;;1890     {
;;;1891       RCC->AHB2LPENR |= RCC_AHB2Periph;
000004  f8d21854          LDR      r1,[r2,#0x854]
000008  4301              ORRS     r1,r1,r0
00000a  f8c21854          STR      r1,[r2,#0x854]
;;;1892     }
;;;1893     else
;;;1894     {
;;;1895       RCC->AHB2LPENR &= ~RCC_AHB2Periph;
;;;1896     }
;;;1897   }
00000e  4770              BX       lr
                  |L5.16|
000010  f8d21854          LDR      r1,[r2,#0x854]        ;1895
000014  4381              BICS     r1,r1,r0              ;1895
000016  f8c21854          STR      r1,[r2,#0x854]        ;1895
00001a  4770              BX       lr
;;;1898   
                          ENDP

                  |L5.28|
                          DCD      0x40023000

                          AREA ||i.RCC_AHB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB2PeriphResetCmd PROC
;;;1687     */
;;;1688   void RCC_AHB2PeriphResetCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
000000  4a06              LDR      r2,|L6.28|
;;;1689   {
;;;1690     /* Check the parameters */
;;;1691     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;1692     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1693   
;;;1694     if (NewState != DISABLE)
000002  b129              CBZ      r1,|L6.16|
;;;1695     {
;;;1696       RCC->AHB2RSTR |= RCC_AHB2Periph;
000004  f8d21814          LDR      r1,[r2,#0x814]
000008  4301              ORRS     r1,r1,r0
00000a  f8c21814          STR      r1,[r2,#0x814]
;;;1697     }
;;;1698     else
;;;1699     {
;;;1700       RCC->AHB2RSTR &= ~RCC_AHB2Periph;
;;;1701     }
;;;1702   }
00000e  4770              BX       lr
                  |L6.16|
000010  f8d21814          LDR      r1,[r2,#0x814]        ;1700
000014  4381              BICS     r1,r1,r0              ;1700
000016  f8c21814          STR      r1,[r2,#0x814]        ;1700
00001a  4770              BX       lr
;;;1703   
                          ENDP

                  |L6.28|
                          DCD      0x40023000

                          AREA ||i.RCC_AHB3PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB3PeriphClockCmd PROC
;;;1519     */
;;;1520   void RCC_AHB3PeriphClockCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000000  4a06              LDR      r2,|L7.28|
;;;1521   {
;;;1522     /* Check the parameters */
;;;1523     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
;;;1524     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1525   
;;;1526     if (NewState != DISABLE)
000002  b129              CBZ      r1,|L7.16|
;;;1527     {
;;;1528       RCC->AHB3ENR |= RCC_AHB3Periph;
000004  f8d21838          LDR      r1,[r2,#0x838]
000008  4301              ORRS     r1,r1,r0
00000a  f8c21838          STR      r1,[r2,#0x838]
;;;1529     }
;;;1530     else
;;;1531     {
;;;1532       RCC->AHB3ENR &= ~RCC_AHB3Periph;
;;;1533     }
;;;1534   }
00000e  4770              BX       lr
                  |L7.16|
000010  f8d21838          LDR      r1,[r2,#0x838]        ;1532
000014  4381              BICS     r1,r1,r0              ;1532
000016  f8c21838          STR      r1,[r2,#0x838]        ;1532
00001a  4770              BX       lr
;;;1535   
                          ENDP

                  |L7.28|
                          DCD      0x40023000

                          AREA ||i.RCC_AHB3PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB3PeriphClockLPModeCmd PROC
;;;1911     */
;;;1912   void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000000  4a06              LDR      r2,|L8.28|
;;;1913   {
;;;1914     /* Check the parameters */
;;;1915     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
;;;1916     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1917     if (NewState != DISABLE)
000002  b129              CBZ      r1,|L8.16|
;;;1918     {
;;;1919       RCC->AHB3LPENR |= RCC_AHB3Periph;
000004  f8d21858          LDR      r1,[r2,#0x858]
000008  4301              ORRS     r1,r1,r0
00000a  f8c21858          STR      r1,[r2,#0x858]
;;;1920     }
;;;1921     else
;;;1922     {
;;;1923       RCC->AHB3LPENR &= ~RCC_AHB3Periph;
;;;1924     }
;;;1925   }
00000e  4770              BX       lr
                  |L8.16|
000010  f8d21858          LDR      r1,[r2,#0x858]        ;1923
000014  4381              BICS     r1,r1,r0              ;1923
000016  f8c21858          STR      r1,[r2,#0x858]        ;1923
00001a  4770              BX       lr
;;;1926   
                          ENDP

                  |L8.28|
                          DCD      0x40023000

                          AREA ||i.RCC_AHB3PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB3PeriphResetCmd PROC
;;;1712     */
;;;1713   void RCC_AHB3PeriphResetCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000000  4a06              LDR      r2,|L9.28|
;;;1714   {
;;;1715     /* Check the parameters */
;;;1716     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
;;;1717     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1718   
;;;1719     if (NewState != DISABLE)
000002  b129              CBZ      r1,|L9.16|
;;;1720     {
;;;1721       RCC->AHB3RSTR |= RCC_AHB3Periph;
000004  f8d21818          LDR      r1,[r2,#0x818]
000008  4301              ORRS     r1,r1,r0
00000a  f8c21818          STR      r1,[r2,#0x818]
;;;1722     }
;;;1723     else
;;;1724     {
;;;1725       RCC->AHB3RSTR &= ~RCC_AHB3Periph;
;;;1726     }
;;;1727   }
00000e  4770              BX       lr
                  |L9.16|
000010  f8d21818          LDR      r1,[r2,#0x818]        ;1725
000014  4381              BICS     r1,r1,r0              ;1725
000016  f8c21818          STR      r1,[r2,#0x818]        ;1725
00001a  4770              BX       lr
;;;1728   
                          ENDP

                  |L9.28|
                          DCD      0x40023000

                          AREA ||i.RCC_APB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockCmd PROC
;;;1571     */
;;;1572   void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  4a06              LDR      r2,|L10.28|
;;;1573   {
;;;1574     /* Check the parameters */
;;;1575     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
;;;1576     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1577   
;;;1578     if (NewState != DISABLE)
000002  b129              CBZ      r1,|L10.16|
;;;1579     {
;;;1580       RCC->APB1ENR |= RCC_APB1Periph;
000004  f8d21840          LDR      r1,[r2,#0x840]
000008  4301              ORRS     r1,r1,r0
00000a  f8c21840          STR      r1,[r2,#0x840]
;;;1581     }
;;;1582     else
;;;1583     {
;;;1584       RCC->APB1ENR &= ~RCC_APB1Periph;
;;;1585     }
;;;1586   }
00000e  4770              BX       lr
                  |L10.16|
000010  f8d21840          LDR      r1,[r2,#0x840]        ;1584
000014  4381              BICS     r1,r1,r0              ;1584
000016  f8c21840          STR      r1,[r2,#0x840]        ;1584
00001a  4770              BX       lr
;;;1587   
                          ENDP

                  |L10.28|
                          DCD      0x40023000

                          AREA ||i.RCC_APB1PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockLPModeCmd PROC
;;;1963     */
;;;1964   void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  4a06              LDR      r2,|L11.28|
;;;1965   {
;;;1966     /* Check the parameters */
;;;1967     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1968     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1969     if (NewState != DISABLE)
000002  b129              CBZ      r1,|L11.16|
;;;1970     {
;;;1971       RCC->APB1LPENR |= RCC_APB1Periph;
000004  f8d21860          LDR      r1,[r2,#0x860]
000008  4301              ORRS     r1,r1,r0
00000a  f8c21860          STR      r1,[r2,#0x860]
;;;1972     }
;;;1973     else
;;;1974     {
;;;1975       RCC->APB1LPENR &= ~RCC_APB1Periph;
;;;1976     }
;;;1977   }
00000e  4770              BX       lr
                  |L11.16|
000010  f8d21860          LDR      r1,[r2,#0x860]        ;1975
000014  4381              BICS     r1,r1,r0              ;1975
000016  f8c21860          STR      r1,[r2,#0x860]        ;1975
00001a  4770              BX       lr
;;;1978   
                          ENDP

                  |L11.28|
                          DCD      0x40023000

                          AREA ||i.RCC_APB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphResetCmd PROC
;;;1761     */
;;;1762   void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  4a06              LDR      r2,|L12.28|
;;;1763   {
;;;1764     /* Check the parameters */
;;;1765     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1766     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1767     if (NewState != DISABLE)
000002  b129              CBZ      r1,|L12.16|
;;;1768     {
;;;1769       RCC->APB1RSTR |= RCC_APB1Periph;
000004  f8d21820          LDR      r1,[r2,#0x820]
000008  4301              ORRS     r1,r1,r0
00000a  f8c21820          STR      r1,[r2,#0x820]
;;;1770     }
;;;1771     else
;;;1772     {
;;;1773       RCC->APB1RSTR &= ~RCC_APB1Periph;
;;;1774     }
;;;1775   }
00000e  4770              BX       lr
                  |L12.16|
000010  f8d21820          LDR      r1,[r2,#0x820]        ;1773
000014  4381              BICS     r1,r1,r0              ;1773
000016  f8c21820          STR      r1,[r2,#0x820]        ;1773
00001a  4770              BX       lr
;;;1776   
                          ENDP

                  |L12.28|
                          DCD      0x40023000

                          AREA ||i.RCC_APB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockCmd PROC
;;;1616     */
;;;1617   void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  4a06              LDR      r2,|L13.28|
;;;1618   {
;;;1619     /* Check the parameters */
;;;1620     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1621     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1622   
;;;1623     if (NewState != DISABLE)
000002  b129              CBZ      r1,|L13.16|
;;;1624     {
;;;1625       RCC->APB2ENR |= RCC_APB2Periph;
000004  f8d21844          LDR      r1,[r2,#0x844]
000008  4301              ORRS     r1,r1,r0
00000a  f8c21844          STR      r1,[r2,#0x844]
;;;1626     }
;;;1627     else
;;;1628     {
;;;1629       RCC->APB2ENR &= ~RCC_APB2Periph;
;;;1630     }
;;;1631   }
00000e  4770              BX       lr
                  |L13.16|
000010  f8d21844          LDR      r1,[r2,#0x844]        ;1629
000014  4381              BICS     r1,r1,r0              ;1629
000016  f8c21844          STR      r1,[r2,#0x844]        ;1629
00001a  4770              BX       lr
;;;1632   
                          ENDP

                  |L13.28|
                          DCD      0x40023000

                          AREA ||i.RCC_APB2PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockLPModeCmd PROC
;;;2008     */
;;;2009   void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  4a06              LDR      r2,|L14.28|
;;;2010   {
;;;2011     /* Check the parameters */
;;;2012     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;2013     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2014     if (NewState != DISABLE)
000002  b129              CBZ      r1,|L14.16|
;;;2015     {
;;;2016       RCC->APB2LPENR |= RCC_APB2Periph;
000004  f8d21864          LDR      r1,[r2,#0x864]
000008  4301              ORRS     r1,r1,r0
00000a  f8c21864          STR      r1,[r2,#0x864]
;;;2017     }
;;;2018     else
;;;2019     {
;;;2020       RCC->APB2LPENR &= ~RCC_APB2Periph;
;;;2021     }
;;;2022   }
00000e  4770              BX       lr
                  |L14.16|
000010  f8d21864          LDR      r1,[r2,#0x864]        ;2020
000014  4381              BICS     r1,r1,r0              ;2020
000016  f8c21864          STR      r1,[r2,#0x864]        ;2020
00001a  4770              BX       lr
;;;2023   
                          ENDP

                  |L14.28|
                          DCD      0x40023000

                          AREA ||i.RCC_APB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphResetCmd PROC
;;;1802     */
;;;1803   void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  4a06              LDR      r2,|L15.28|
;;;1804   {
;;;1805     /* Check the parameters */
;;;1806     assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
;;;1807     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1808     if (NewState != DISABLE)
000002  b129              CBZ      r1,|L15.16|
;;;1809     {
;;;1810       RCC->APB2RSTR |= RCC_APB2Periph;
000004  f8d21824          LDR      r1,[r2,#0x824]
000008  4301              ORRS     r1,r1,r0
00000a  f8c21824          STR      r1,[r2,#0x824]
;;;1811     }
;;;1812     else
;;;1813     {
;;;1814       RCC->APB2RSTR &= ~RCC_APB2Periph;
;;;1815     }
;;;1816   }
00000e  4770              BX       lr
                  |L15.16|
000010  f8d21824          LDR      r1,[r2,#0x824]        ;1814
000014  4381              BICS     r1,r1,r0              ;1814
000016  f8c21824          STR      r1,[r2,#0x824]        ;1814
00001a  4770              BX       lr
;;;1817   
                          ENDP

                  |L15.28|
                          DCD      0x40023000

                          AREA ||i.RCC_AdjustHSICalibrationValue||, CODE, READONLY, ALIGN=2

                  RCC_AdjustHSICalibrationValue PROC
;;;318      */
;;;319    void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
000000  4a03              LDR      r2,|L16.16|
;;;320    {
;;;321      uint32_t tmpreg = 0;
;;;322      /* Check the parameters */
;;;323      assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
;;;324    
;;;325      tmpreg = RCC->CR;
000002  6811              LDR      r1,[r2,#0]
;;;326    
;;;327      /* Clear HSITRIM[4:0] bits */
;;;328      tmpreg &= ~RCC_CR_HSITRIM;
000004  f02101f8          BIC      r1,r1,#0xf8
;;;329    
;;;330      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;331      tmpreg |= (uint32_t)HSICalibrationValue << 3;
000008  ea4100c0          ORR      r0,r1,r0,LSL #3
;;;332    
;;;333      /* Store the new value */
;;;334      RCC->CR = tmpreg;
00000c  6010              STR      r0,[r2,#0]
;;;335    }
00000e  4770              BX       lr
;;;336    
                          ENDP

                  |L16.16|
                          DCD      0x40023800

                          AREA ||i.RCC_BackupResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_BackupResetCmd PROC
;;;1204     */
;;;1205   void RCC_BackupResetCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L17.8|
;;;1206   {
;;;1207     /* Check the parameters */
;;;1208     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1209     *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;1210   }
000004  4770              BX       lr
;;;1211   
                          ENDP

000006  0000              DCW      0x0000
                  |L17.8|
                          DCD      0x42470e40

                          AREA ||i.RCC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RCC_ClearFlag PROC
;;;2136     */
;;;2137   void RCC_ClearFlag(void)
000000  4802              LDR      r0,|L18.12|
;;;2138   {
;;;2139     /* Set RMVF bit to clear the reset flags */
;;;2140     RCC->CSR |= RCC_CSR_RMVF;
000002  6801              LDR      r1,[r0,#0]
000004  f0417180          ORR      r1,r1,#0x1000000
000008  6001              STR      r1,[r0,#0]
;;;2141   }
00000a  4770              BX       lr
;;;2142   
                          ENDP

                  |L18.12|
                          DCD      0x40023874

                          AREA ||i.RCC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RCC_ClearITPendingBit PROC
;;;2190     */
;;;2191   void RCC_ClearITPendingBit(uint8_t RCC_IT)
000000  4901              LDR      r1,|L19.8|
;;;2192   {
;;;2193     /* Check the parameters */
;;;2194     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
;;;2195   
;;;2196     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;2197        pending bits */
;;;2198     *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
000002  7008              STRB     r0,[r1,#0]
;;;2199   }
000004  4770              BX       lr
;;;2200   
                          ENDP

000006  0000              DCW      0x0000
                  |L19.8|
                          DCD      0x4002380e

                          AREA ||i.RCC_ClockSecuritySystemCmd||, CODE, READONLY, ALIGN=2

                  RCC_ClockSecuritySystemCmd PROC
;;;633      */
;;;634    void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L20.8|
;;;635    {
;;;636      /* Check the parameters */
;;;637      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;638      *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
000002  64c8              STR      r0,[r1,#0x4c]
;;;639    }
000004  4770              BX       lr
;;;640    
                          ENDP

000006  0000              DCW      0x0000
                  |L20.8|
                          DCD      0x42470000

                          AREA ||i.RCC_DeInit||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;212      */
;;;213    void RCC_DeInit(void)
000000  480e              LDR      r0,|L21.60|
;;;214    {
;;;215      /* Set HSION bit */
;;;216      RCC->CR |= (uint32_t)0x00000001;
000002  6801              LDR      r1,[r0,#0]
000004  f0410101          ORR      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
;;;217    
;;;218      /* Reset CFGR register */
;;;219      RCC->CFGR = 0x00000000;
00000a  f04f0100          MOV      r1,#0
00000e  6081              STR      r1,[r0,#8]
;;;220    
;;;221      /* Reset HSEON, CSSON, PLLON, PLLI2S and PLLSAI(STM32F42/43xxx devices) bits */
;;;222      RCC->CR &= (uint32_t)0xEAF6FFFF;
000010  6802              LDR      r2,[r0,#0]
000012  4b0b              LDR      r3,|L21.64|
000014  ea020203          AND      r2,r2,r3
000018  6002              STR      r2,[r0,#0]
;;;223    
;;;224      /* Reset PLLCFGR register */
;;;225      RCC->PLLCFGR = 0x24003010;
00001a  4a0a              LDR      r2,|L21.68|
00001c  6042              STR      r2,[r0,#4]
;;;226    
;;;227      /* Reset PLLI2SCFGR register */
;;;228      RCC->PLLI2SCFGR = 0x20003000;
00001e  4a0a              LDR      r2,|L21.72|
000020  f8c02084          STR      r2,[r0,#0x84]
;;;229    
;;;230      /* Reset PLLSAICFGR register, only available for STM32F42/43xxx devices */
;;;231      RCC->PLLSAICFGR = 0x24003000;
000024  4a09              LDR      r2,|L21.76|
000026  f8c02088          STR      r2,[r0,#0x88]
;;;232     
;;;233      /* Reset HSEBYP bit */
;;;234      RCC->CR &= (uint32_t)0xFFFBFFFF;
00002a  6802              LDR      r2,[r0,#0]
00002c  f4222280          BIC      r2,r2,#0x40000
000030  6002              STR      r2,[r0,#0]
;;;235    
;;;236      /* Disable all interrupts */
;;;237      RCC->CIR = 0x00000000;
000032  60c1              STR      r1,[r0,#0xc]
;;;238    
;;;239      /* Disable Timers clock prescalers selection, only available for STM32F42/43xxx devices */
;;;240      RCC->DCKCFGR = 0x00000000; 
000034  f8c0108c          STR      r1,[r0,#0x8c]
;;;241    
;;;242    }
000038  4770              BX       lr
;;;243    
                          ENDP

00003a  0000              DCW      0x0000
                  |L21.60|
                          DCD      0x40023800
                  |L21.64|
                          DCD      0xeaf6ffff
                  |L21.68|
                          DCD      0x24003010
                  |L21.72|
                          DCD      0x20003000
                  |L21.76|
                          DCD      0x24003000

                          AREA ||i.RCC_GetClocksFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetClocksFreq PROC
;;;1030     */
;;;1031   void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
000000  b510              PUSH     {r4,lr}
;;;1032   {
;;;1033     uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
;;;1034   
;;;1035     /* Get SYSCLK source -------------------------------------------------------*/
;;;1036     tmp = RCC->CFGR & RCC_CFGR_SWS;
000002  4a2b              LDR      r2,|L22.176|
000004  f8d21808          LDR      r1,[r2,#0x808]
000008  f001010c          AND      r1,r1,#0xc
;;;1037   
;;;1038     switch (tmp)
;;;1039     {
;;;1040       case 0x00:  /* HSI used as system clock source */
;;;1041         RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
00000c  4b29              LDR      r3,|L22.180|
00000e  b339              CBZ      r1,|L22.96|
;;;1042         break;
;;;1043       case 0x04:  /* HSE used as system clock  source */
;;;1044         RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
000010  4c29              LDR      r4,|L22.184|
000012  2904              CMP      r1,#4                 ;1038
000014  d026              BEQ      |L22.100|
000016  2908              CMP      r1,#8                 ;1038
000018  d026              BEQ      |L22.104|
;;;1045         break;
;;;1046       case 0x08:  /* PLL used as system clock  source */
;;;1047   
;;;1048         /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
;;;1049            SYSCLK = PLL_VCO / PLLP
;;;1050            */    
;;;1051         pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
;;;1052         pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
;;;1053         
;;;1054         if (pllsource != 0)
;;;1055         {
;;;1056           /* HSE used as PLL clock source */
;;;1057           pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
;;;1058         }
;;;1059         else
;;;1060         {
;;;1061           /* HSI used as PLL clock source */
;;;1062           pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
;;;1063         }
;;;1064   
;;;1065         pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
;;;1066         RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
;;;1067         break;
;;;1068       default:
;;;1069         RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
00001a  6003              STR      r3,[r0,#0]
                  |L22.28|
;;;1070         break;
;;;1071     }
;;;1072     /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/
;;;1073   
;;;1074     /* Get HCLK prescaler */
;;;1075     tmp = RCC->CFGR & RCC_CFGR_HPRE;
00001c  f6020208          ADD      r2,r2,#0x808
000020  6811              LDR      r1,[r2,#0]
000022  f00101f0          AND      r1,r1,#0xf0
;;;1076     tmp = tmp >> 4;
000026  ea4f1111          LSR      r1,r1,#4
;;;1077     presc = APBAHBPrescTable[tmp];
00002a  4b24              LDR      r3,|L22.188|
00002c  f813c001          LDRB     r12,[r3,r1]
;;;1078     /* HCLK clock frequency */
;;;1079     RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
000030  6801              LDR      r1,[r0,#0]
000032  fa21f10c          LSR      r1,r1,r12
000036  6041              STR      r1,[r0,#4]
;;;1080   
;;;1081     /* Get PCLK1 prescaler */
;;;1082     tmp = RCC->CFGR & RCC_CFGR_PPRE1;
000038  6814              LDR      r4,[r2,#0]
00003a  f4045ce0          AND      r12,r4,#0x1c00
;;;1083     tmp = tmp >> 10;
00003e  ea4f2c9c          LSR      r12,r12,#10
;;;1084     presc = APBAHBPrescTable[tmp];
000042  f813c00c          LDRB     r12,[r3,r12]
;;;1085     /* PCLK1 clock frequency */
;;;1086     RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
000046  fa21f40c          LSR      r4,r1,r12
00004a  6084              STR      r4,[r0,#8]
;;;1087   
;;;1088     /* Get PCLK2 prescaler */
;;;1089     tmp = RCC->CFGR & RCC_CFGR_PPRE2;
00004c  6812              LDR      r2,[r2,#0]
00004e  f4024260          AND      r2,r2,#0xe000
;;;1090     tmp = tmp >> 13;
000052  ea4f3252          LSR      r2,r2,#13
;;;1091     presc = APBAHBPrescTable[tmp];
000056  5c9a              LDRB     r2,[r3,r2]
;;;1092     /* PCLK2 clock frequency */
;;;1093     RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
000058  fa21f102          LSR      r1,r1,r2
00005c  60c1              STR      r1,[r0,#0xc]
;;;1094   }
00005e  bd10              POP      {r4,pc}
                  |L22.96|
000060  6003              STR      r3,[r0,#0]            ;1041
000062  e7db              B        |L22.28|
                  |L22.100|
000064  6004              STR      r4,[r0,#0]            ;1044
000066  e7d9              B        |L22.28|
                  |L22.104|
000068  f8d21804          LDR      r1,[r2,#0x804]        ;1051
00006c  f3c15c80          UBFX     r12,r1,#22,#1         ;1051
000070  f8d21804          LDR      r1,[r2,#0x804]        ;1052
000074  f001013f          AND      r1,r1,#0x3f           ;1052
000078  f1bc0f00          CMP      r12,#0                ;1054
00007c  d007              BEQ      |L22.142|
00007e  fbb4f1f1          UDIV     r1,r4,r1              ;1057
000082  f8d23804          LDR      r3,[r2,#0x804]        ;1057
000086  f3c31388          UBFX     r3,r3,#6,#9           ;1057
00008a  4359              MULS     r1,r3,r1              ;1057
00008c  e006              B        |L22.156|
                  |L22.142|
00008e  fbb3f1f1          UDIV     r1,r3,r1              ;1062
000092  f8d23804          LDR      r3,[r2,#0x804]        ;1062
000096  f3c31388          UBFX     r3,r3,#6,#9           ;1062
00009a  4359              MULS     r1,r3,r1              ;1062
                  |L22.156|
00009c  f8d23804          LDR      r3,[r2,#0x804]        ;1065
0000a0  f3c34301          UBFX     r3,r3,#16,#2          ;1065
0000a4  1c5b              ADDS     r3,r3,#1              ;1065
0000a6  005b              LSLS     r3,r3,#1              ;1065
0000a8  fbb1f1f3          UDIV     r1,r1,r3              ;1066
0000ac  6001              STR      r1,[r0,#0]            ;1066
0000ae  e7b5              B        |L22.28|
;;;1095   
                          ENDP

                  |L22.176|
                          DCD      0x40023000
                  |L22.180|
                          DCD      0x00f42400
                  |L22.184|
                          DCD      0x017d7840
                  |L22.188|
                          DCD      ||.data||

                          AREA ||i.RCC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetFlagStatus PROC
;;;2091     */
;;;2092   FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
000000  4603              MOV      r3,r0
;;;2093   {
;;;2094     uint32_t tmp = 0;
;;;2095     uint32_t statusreg = 0;
;;;2096     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;2097   
;;;2098     /* Check the parameters */
;;;2099     assert_param(IS_RCC_FLAG(RCC_FLAG));
;;;2100   
;;;2101     /* Get the RCC register index */
;;;2102     tmp = RCC_FLAG >> 5;
000004  0959              LSRS     r1,r3,#5
;;;2103     if (tmp == 1)               /* The flag to check is in CR register */
;;;2104     {
;;;2105       statusreg = RCC->CR;
000006  4a0a              LDR      r2,|L23.48|
000008  2901              CMP      r1,#1                 ;2103
00000a  d00b              BEQ      |L23.36|
;;;2106     }
;;;2107     else if (tmp == 2)          /* The flag to check is in BDCR register */
00000c  2902              CMP      r1,#2
00000e  d00c              BEQ      |L23.42|
;;;2108     {
;;;2109       statusreg = RCC->BDCR;
;;;2110     }
;;;2111     else                       /* The flag to check is in CSR register */
;;;2112     {
;;;2113       statusreg = RCC->CSR;
000010  f8d21874          LDR      r1,[r2,#0x874]
                  |L23.20|
;;;2114     }
;;;2115   
;;;2116     /* Get the flag position */
;;;2117     tmp = RCC_FLAG & FLAG_MASK;
000014  f003021f          AND      r2,r3,#0x1f
;;;2118     if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
000018  2301              MOVS     r3,#1
00001a  4093              LSLS     r3,r3,r2
00001c  420b              TST      r3,r1
00001e  d000              BEQ      |L23.34|
;;;2119     {
;;;2120       bitstatus = SET;
000020  2001              MOVS     r0,#1
                  |L23.34|
;;;2121     }
;;;2122     else
;;;2123     {
;;;2124       bitstatus = RESET;
;;;2125     }
;;;2126     /* Return the flag status */
;;;2127     return bitstatus;
;;;2128   }
000022  4770              BX       lr
                  |L23.36|
000024  f8d21800          LDR      r1,[r2,#0x800]        ;2105
000028  e7f4              B        |L23.20|
                  |L23.42|
00002a  f8d21870          LDR      r1,[r2,#0x870]        ;2109
00002e  e7f1              B        |L23.20|
;;;2129   
                          ENDP

                  |L23.48|
                          DCD      0x40023000

                          AREA ||i.RCC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetITStatus PROC
;;;2156     */
;;;2157   ITStatus RCC_GetITStatus(uint8_t RCC_IT)
000000  4601              MOV      r1,r0
;;;2158   {
;;;2159     ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;2160   
;;;2161     /* Check the parameters */
;;;2162     assert_param(IS_RCC_GET_IT(RCC_IT));
;;;2163   
;;;2164     /* Check the status of the specified RCC interrupt */
;;;2165     if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
000004  4a02              LDR      r2,|L24.16|
000006  6812              LDR      r2,[r2,#0]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L24.14|
;;;2166     {
;;;2167       bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L24.14|
;;;2168     }
;;;2169     else
;;;2170     {
;;;2171       bitstatus = RESET;
;;;2172     }
;;;2173     /* Return the RCC_IT status */
;;;2174     return  bitstatus;
;;;2175   }
00000e  4770              BX       lr
;;;2176   
                          ENDP

                  |L24.16|
                          DCD      0x4002380c

                          AREA ||i.RCC_GetSYSCLKSource||, CODE, READONLY, ALIGN=2

                  RCC_GetSYSCLKSource PROC
;;;890      */
;;;891    uint8_t RCC_GetSYSCLKSource(void)
000000  4802              LDR      r0,|L25.12|
;;;892    {
;;;893      return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
000002  6800              LDR      r0,[r0,#0]
000004  f000000c          AND      r0,r0,#0xc
;;;894    }
000008  4770              BX       lr
;;;895    
                          ENDP

00000a  0000              DCW      0x0000
                  |L25.12|
                          DCD      0x40023808

                          AREA ||i.RCC_HCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_HCLKConfig PROC
;;;915      */
;;;916    void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
000000  4a03              LDR      r2,|L26.16|
;;;917    {
;;;918      uint32_t tmpreg = 0;
;;;919      
;;;920      /* Check the parameters */
;;;921      assert_param(IS_RCC_HCLK(RCC_SYSCLK));
;;;922    
;;;923      tmpreg = RCC->CFGR;
000002  6811              LDR      r1,[r2,#0]
;;;924    
;;;925      /* Clear HPRE[3:0] bits */
;;;926      tmpreg &= ~RCC_CFGR_HPRE;
000004  f02101f0          BIC      r1,r1,#0xf0
;;;927    
;;;928      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;929      tmpreg |= RCC_SYSCLK;
000008  ea410100          ORR      r1,r1,r0
;;;930    
;;;931      /* Store the new value */
;;;932      RCC->CFGR = tmpreg;
00000c  6011              STR      r1,[r2,#0]
;;;933    }
00000e  4770              BX       lr
;;;934    
                          ENDP

                  |L26.16|
                          DCD      0x40023808

                          AREA ||i.RCC_HSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_HSEConfig PROC
;;;263      */
;;;264    void RCC_HSEConfig(uint8_t RCC_HSE)
000000  4902              LDR      r1,|L27.12|
;;;265    {
;;;266      /* Check the parameters */
;;;267      assert_param(IS_RCC_HSE(RCC_HSE));
;;;268    
;;;269      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;270      *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
000002  2200              MOVS     r2,#0
000004  700a              STRB     r2,[r1,#0]
;;;271    
;;;272      /* Set the new HSE configuration -------------------------------------------*/
;;;273      *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
000006  7008              STRB     r0,[r1,#0]
;;;274    }
000008  4770              BX       lr
;;;275    
                          ENDP

00000a  0000              DCW      0x0000
                  |L27.12|
                          DCD      0x40023802

                          AREA ||i.RCC_HSICmd||, CODE, READONLY, ALIGN=2

                  RCC_HSICmd PROC
;;;354      */
;;;355    void RCC_HSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L28.8|
;;;356    {
;;;357      /* Check the parameters */
;;;358      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;359    
;;;360      *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;361    }
000004  4770              BX       lr
;;;362    
                          ENDP

000006  0000              DCW      0x0000
                  |L28.8|
                          DCD      0x42470000

                          AREA ||i.RCC_I2SCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_I2SCLKConfig PROC
;;;1221     */
;;;1222   void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
000000  4901              LDR      r1,|L29.8|
;;;1223   {
;;;1224     /* Check the parameters */
;;;1225     assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));
;;;1226   
;;;1227     *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
000002  6008              STR      r0,[r1,#0]
;;;1228   }
000004  4770              BX       lr
;;;1229   
                          ENDP

000006  0000              DCW      0x0000
                  |L29.8|
                          DCD      0x4247015c

                          AREA ||i.RCC_ITConfig||, CODE, READONLY, ALIGN=2

                  RCC_ITConfig PROC
;;;2054     */
;;;2055   void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
000000  4a06              LDR      r2,|L30.28|
;;;2056   {
;;;2057     /* Check the parameters */
;;;2058     assert_param(IS_RCC_IT(RCC_IT));
;;;2059     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2060     if (NewState != DISABLE)
000002  b129              CBZ      r1,|L30.16|
;;;2061     {
;;;2062       /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
;;;2063       *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
000004  f892180d          LDRB     r1,[r2,#0x80d]
000008  4301              ORRS     r1,r1,r0
00000a  f882180d          STRB     r1,[r2,#0x80d]
;;;2064     }
;;;2065     else
;;;2066     {
;;;2067       /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
;;;2068       *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
;;;2069     }
;;;2070   }
00000e  4770              BX       lr
                  |L30.16|
000010  f892180d          LDRB     r1,[r2,#0x80d]        ;2068
000014  4381              BICS     r1,r1,r0              ;2068
000016  f882180d          STRB     r1,[r2,#0x80d]        ;2068
00001a  4770              BX       lr
;;;2071   
                          ENDP

                  |L30.28|
                          DCD      0x40023000

                          AREA ||i.RCC_LSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_LSEConfig PROC
;;;379      */
;;;380    void RCC_LSEConfig(uint8_t RCC_LSE)
000000  4908              LDR      r1,|L31.36|
;;;381    {
;;;382      /* Check the parameters */
;;;383      assert_param(IS_RCC_LSE(RCC_LSE));
;;;384    
;;;385      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;386      /* Reset LSEON bit */
;;;387      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
000002  2200              MOVS     r2,#0
000004  f8812870          STRB     r2,[r1,#0x870]
;;;388    
;;;389      /* Reset LSEBYP bit */
;;;390      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
000008  f8812870          STRB     r2,[r1,#0x870]
;;;391    
;;;392      /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
;;;393      switch (RCC_LSE)
00000c  2801              CMP      r0,#1
00000e  d005              BEQ      |L31.28|
000010  2804              CMP      r0,#4
000012  d102              BNE      |L31.26|
;;;394      {
;;;395        case RCC_LSE_ON:
;;;396          /* Set LSEON bit */
;;;397          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
;;;398          break;
;;;399        case RCC_LSE_Bypass:
;;;400          /* Set LSEBYP and LSEON bits */
;;;401          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
000014  2005              MOVS     r0,#5
000016  f8810870          STRB     r0,[r1,#0x870]
                  |L31.26|
;;;402          break;
;;;403        default:
;;;404          break;
;;;405      }
;;;406    }
00001a  4770              BX       lr
                  |L31.28|
00001c  2001              MOVS     r0,#1                 ;397
00001e  f8810870          STRB     r0,[r1,#0x870]        ;397
000022  4770              BX       lr
;;;407    
                          ENDP

                  |L31.36|
                          DCD      0x40023000

                          AREA ||i.RCC_LSICmd||, CODE, READONLY, ALIGN=2

                  RCC_LSICmd PROC
;;;419      */
;;;420    void RCC_LSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L32.8|
;;;421    {
;;;422      /* Check the parameters */
;;;423      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;424    
;;;425      *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;426    }
000004  4770              BX       lr
;;;427    
                          ENDP

000006  0000              DCW      0x0000
                  |L32.8|
                          DCD      0x42470e80

                          AREA ||i.RCC_LTDCCLKDivConfig||, CODE, READONLY, ALIGN=2

                  RCC_LTDCCLKDivConfig PROC
;;;1379     */
;;;1380   void RCC_LTDCCLKDivConfig(uint32_t RCC_PLLSAIDivR)
000000  4a03              LDR      r2,|L33.16|
;;;1381   {
;;;1382     uint32_t tmpreg = 0;
;;;1383     
;;;1384     /* Check the parameters */
;;;1385     assert_param(IS_RCC_PLLSAI_DIVR_VALUE(RCC_PLLSAIDivR));
;;;1386     
;;;1387     tmpreg = RCC->DCKCFGR;
000002  6811              LDR      r1,[r2,#0]
;;;1388   
;;;1389     /* Clear PLLSAIDIVR[2:0] bits */
;;;1390     tmpreg &= ~RCC_DCKCFGR_PLLSAIDIVR;
000004  f4213140          BIC      r1,r1,#0x30000
;;;1391   
;;;1392     /* Set PLLSAIDIVR values */
;;;1393     tmpreg |= RCC_PLLSAIDivR;
000008  ea410100          ORR      r1,r1,r0
;;;1394   
;;;1395     /* Store the new value */
;;;1396     RCC->DCKCFGR = tmpreg;
00000c  6011              STR      r1,[r2,#0]
;;;1397   }
00000e  4770              BX       lr
;;;1398   
                          ENDP

                  |L33.16|
                          DCD      0x4002388c

                          AREA ||i.RCC_MCO1Config||, CODE, READONLY, ALIGN=2

                  RCC_MCO1Config PROC
;;;658      */
;;;659    void RCC_MCO1Config(uint32_t RCC_MCO1Source, uint32_t RCC_MCO1Div)
000000  4b04              LDR      r3,|L34.20|
;;;660    {
;;;661      uint32_t tmpreg = 0;
;;;662      
;;;663      /* Check the parameters */
;;;664      assert_param(IS_RCC_MCO1SOURCE(RCC_MCO1Source));
;;;665      assert_param(IS_RCC_MCO1DIV(RCC_MCO1Div));  
;;;666    
;;;667      tmpreg = RCC->CFGR;
000002  681a              LDR      r2,[r3,#0]
;;;668    
;;;669      /* Clear MCO1[1:0] and MCO1PRE[2:0] bits */
;;;670      tmpreg &= CFGR_MCO1_RESET_MASK;
000004  f02262ec          BIC      r2,r2,#0x7600000
;;;671    
;;;672      /* Select MCO1 clock source and prescaler */
;;;673      tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
000008  ea400001          ORR      r0,r0,r1
00000c  ea400002          ORR      r0,r0,r2
;;;674    
;;;675      /* Store the new value */
;;;676      RCC->CFGR = tmpreg;  
000010  6018              STR      r0,[r3,#0]
;;;677    }
000012  4770              BX       lr
;;;678    
                          ENDP

                  |L34.20|
                          DCD      0x40023808

                          AREA ||i.RCC_MCO2Config||, CODE, READONLY, ALIGN=2

                  RCC_MCO2Config PROC
;;;696      */
;;;697    void RCC_MCO2Config(uint32_t RCC_MCO2Source, uint32_t RCC_MCO2Div)
000000  4b04              LDR      r3,|L35.20|
;;;698    {
;;;699      uint32_t tmpreg = 0;
;;;700      
;;;701      /* Check the parameters */
;;;702      assert_param(IS_RCC_MCO2SOURCE(RCC_MCO2Source));
;;;703      assert_param(IS_RCC_MCO2DIV(RCC_MCO2Div));
;;;704      
;;;705      tmpreg = RCC->CFGR;
000002  681a              LDR      r2,[r3,#0]
;;;706      
;;;707      /* Clear MCO2 and MCO2PRE[2:0] bits */
;;;708      tmpreg &= CFGR_MCO2_RESET_MASK;
000004  f0224278          BIC      r2,r2,#0xf8000000
;;;709    
;;;710      /* Select MCO2 clock source and prescaler */
;;;711      tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
000008  ea400001          ORR      r0,r0,r1
00000c  ea400002          ORR      r0,r0,r2
;;;712    
;;;713      /* Store the new value */
;;;714      RCC->CFGR = tmpreg;  
000010  6018              STR      r0,[r3,#0]
;;;715    }
000012  4770              BX       lr
;;;716    
                          ENDP

                  |L35.20|
                          DCD      0x40023808

                          AREA ||i.RCC_PCLK1Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK1Config PROC
;;;947      */
;;;948    void RCC_PCLK1Config(uint32_t RCC_HCLK)
000000  4a03              LDR      r2,|L36.16|
;;;949    {
;;;950      uint32_t tmpreg = 0;
;;;951    
;;;952      /* Check the parameters */
;;;953      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;954    
;;;955      tmpreg = RCC->CFGR;
000002  6811              LDR      r1,[r2,#0]
;;;956    
;;;957      /* Clear PPRE1[2:0] bits */
;;;958      tmpreg &= ~RCC_CFGR_PPRE1;
000004  f42151e0          BIC      r1,r1,#0x1c00
;;;959    
;;;960      /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;961      tmpreg |= RCC_HCLK;
000008  ea410100          ORR      r1,r1,r0
;;;962    
;;;963      /* Store the new value */
;;;964      RCC->CFGR = tmpreg;
00000c  6011              STR      r1,[r2,#0]
;;;965    }
00000e  4770              BX       lr
;;;966    
                          ENDP

                  |L36.16|
                          DCD      0x40023808

                          AREA ||i.RCC_PCLK2Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK2Config PROC
;;;978      */
;;;979    void RCC_PCLK2Config(uint32_t RCC_HCLK)
000000  4a03              LDR      r2,|L37.16|
;;;980    {
;;;981      uint32_t tmpreg = 0;
;;;982    
;;;983      /* Check the parameters */
;;;984      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;985    
;;;986      tmpreg = RCC->CFGR;
000002  6811              LDR      r1,[r2,#0]
;;;987    
;;;988      /* Clear PPRE2[2:0] bits */
;;;989      tmpreg &= ~RCC_CFGR_PPRE2;
000004  f4214160          BIC      r1,r1,#0xe000
;;;990    
;;;991      /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;992      tmpreg |= RCC_HCLK << 3;
000008  ea4100c0          ORR      r0,r1,r0,LSL #3
;;;993    
;;;994      /* Store the new value */
;;;995      RCC->CFGR = tmpreg;
00000c  6010              STR      r0,[r2,#0]
;;;996    }
00000e  4770              BX       lr
;;;997    
                          ENDP

                  |L37.16|
                          DCD      0x40023808

                          AREA ||i.RCC_PLLCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLCmd PROC
;;;485      */
;;;486    void RCC_PLLCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L38.8|
;;;487    {
;;;488      /* Check the parameters */
;;;489      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;490      *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
000002  6608              STR      r0,[r1,#0x60]
;;;491    }
000004  4770              BX       lr
;;;492    
                          ENDP

000006  0000              DCW      0x0000
                  |L38.8|
                          DCD      0x42470000

                          AREA ||i.RCC_PLLConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLConfig PROC
;;;462      */
;;;463    void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ)
000000  b510              PUSH     {r4,lr}
;;;464    {
000002  9c02              LDR      r4,[sp,#8]
;;;465      /* Check the parameters */
;;;466      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
;;;467      assert_param(IS_RCC_PLLM_VALUE(PLLM));
;;;468      assert_param(IS_RCC_PLLN_VALUE(PLLN));
;;;469      assert_param(IS_RCC_PLLP_VALUE(PLLP));
;;;470      assert_param(IS_RCC_PLLQ_VALUE(PLLQ));
;;;471    
;;;472      RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
000004  ea411182          ORR      r1,r1,r2,LSL #6
000008  f04f32ff          MOV      r2,#0xffffffff
00000c  eb020253          ADD      r2,r2,r3,LSR #1
000010  ea414102          ORR      r1,r1,r2,LSL #16
000014  4301              ORRS     r1,r1,r0
000016  ea416004          ORR      r0,r1,r4,LSL #24
00001a  4901              LDR      r1,|L39.32|
00001c  6008              STR      r0,[r1,#0]
;;;473                     (PLLQ << 24);
;;;474    }
00001e  bd10              POP      {r4,pc}
;;;475    
                          ENDP

                  |L39.32|
                          DCD      0x40023804

                          AREA ||i.RCC_PLLI2SCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLI2SCmd PROC
;;;568      */
;;;569    void RCC_PLLI2SCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L40.8|
;;;570    {
;;;571      /* Check the parameters */
;;;572      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;573      *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
000002  6688              STR      r0,[r1,#0x68]
;;;574    }
000004  4770              BX       lr
;;;575    
                          ENDP

000006  0000              DCW      0x0000
                  |L40.8|
                          DCD      0x42470000

                          AREA ||i.RCC_PLLI2SConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLI2SConfig PROC
;;;515      */
;;;516    void RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SR)
000000  0180              LSLS     r0,r0,#6
;;;517    {
;;;518      /* Check the parameters */
;;;519      assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
;;;520      assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));
;;;521    
;;;522      RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28);
000002  ea407001          ORR      r0,r0,r1,LSL #28
000006  4901              LDR      r1,|L41.12|
000008  6008              STR      r0,[r1,#0]
;;;523    }
00000a  4770              BX       lr
;;;524    #endif /* STM32F40_41xxx || STM32F401xx */
                          ENDP

                  |L41.12|
                          DCD      0x40023884

                          AREA ||i.RCC_PLLSAICmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLSAICmd PROC
;;;615      */
;;;616    void RCC_PLLSAICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L42.8|
;;;617    {
;;;618      /* Check the parameters */
;;;619      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;620      *(__IO uint32_t *) CR_PLLSAION_BB = (uint32_t)NewState;
000002  6708              STR      r0,[r1,#0x70]
;;;621    }
000004  4770              BX       lr
;;;622    
                          ENDP

000006  0000              DCW      0x0000
                  |L42.8|
                          DCD      0x42470000

                          AREA ||i.RCC_PLLSAIConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLSAIConfig PROC
;;;597      */
;;;598    void RCC_PLLSAIConfig(uint32_t PLLSAIN, uint32_t PLLSAIQ, uint32_t PLLSAIR)
000000  0180              LSLS     r0,r0,#6
;;;599    {
;;;600      /* Check the parameters */
;;;601      assert_param(IS_RCC_PLLSAIN_VALUE(PLLSAIN));
;;;602      assert_param(IS_RCC_PLLSAIR_VALUE(PLLSAIR));
;;;603    
;;;604      RCC->PLLSAICFGR = (PLLSAIN << 6) | (PLLSAIQ << 24) | (PLLSAIR << 28);
000002  ea406001          ORR      r0,r0,r1,LSL #24
000006  4902              LDR      r1,|L43.16|
000008  ea407002          ORR      r0,r0,r2,LSL #28
00000c  6008              STR      r0,[r1,#0]
;;;605    }
00000e  4770              BX       lr
;;;606    
                          ENDP

                  |L43.16|
                          DCD      0x40023888

                          AREA ||i.RCC_RTCCLKCmd||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKCmd PROC
;;;1187     */
;;;1188   void RCC_RTCCLKCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L44.8|
;;;1189   {
;;;1190     /* Check the parameters */
;;;1191     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1192   
;;;1193     *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;1194   }
000004  4770              BX       lr
;;;1195   
                          ENDP

000006  0000              DCW      0x0000
                  |L44.8|
                          DCD      0x42470e3c

                          AREA ||i.RCC_RTCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKConfig PROC
;;;1155     */
;;;1156   void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
000000  f3c02101          UBFX     r1,r0,#8,#2
;;;1157   {
;;;1158     uint32_t tmpreg = 0;
;;;1159   
;;;1160     /* Check the parameters */
;;;1161     assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
;;;1162   
;;;1163     if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
;;;1164     { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
;;;1165       tmpreg = RCC->CFGR;
000004  4b09              LDR      r3,|L45.44|
000006  2903              CMP      r1,#3                 ;1163
000008  d108              BNE      |L45.28|
00000a  f8d31808          LDR      r1,[r3,#0x808]
;;;1166   
;;;1167       /* Clear RTCPRE[4:0] bits */
;;;1168       tmpreg &= ~RCC_CFGR_RTCPRE;
00000e  f42112f8          BIC      r2,r1,#0x1f0000
;;;1169   
;;;1170       /* Configure HSE division factor for RTC clock */
;;;1171       tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
000012  4907              LDR      r1,|L45.48|
000014  4001              ANDS     r1,r1,r0
000016  4311              ORRS     r1,r1,r2
;;;1172   
;;;1173       /* Store the new value */
;;;1174       RCC->CFGR = tmpreg;
000018  f8c31808          STR      r1,[r3,#0x808]
                  |L45.28|
;;;1175     }
;;;1176       
;;;1177     /* Select the RTC clock source */
;;;1178     RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
00001c  f8d31870          LDR      r1,[r3,#0x870]
000020  f3c0000b          UBFX     r0,r0,#0,#12
000024  4301              ORRS     r1,r1,r0
000026  f8c31870          STR      r1,[r3,#0x870]
;;;1179   }
00002a  4770              BX       lr
;;;1180   
                          ENDP

                  |L45.44|
                          DCD      0x40023000
                  |L45.48|
                          DCD      0x0ffffcff

                          AREA ||i.RCC_SAIBlockACLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SAIBlockACLKConfig PROC
;;;1310     */
;;;1311   void RCC_SAIBlockACLKConfig(uint32_t RCC_SAIBlockACLKSource)
000000  4a03              LDR      r2,|L46.16|
;;;1312   {
;;;1313     uint32_t tmpreg = 0;
;;;1314     
;;;1315     /* Check the parameters */
;;;1316     assert_param(IS_RCC_SAIACLK_SOURCE(RCC_SAIBlockACLKSource));
;;;1317     
;;;1318     tmpreg = RCC->DCKCFGR;
000002  6811              LDR      r1,[r2,#0]
;;;1319   
;;;1320     /* Clear RCC_DCKCFGR_SAI1ASRC[1:0] bits */
;;;1321     tmpreg &= ~RCC_DCKCFGR_SAI1ASRC;
000004  f4211140          BIC      r1,r1,#0x300000
;;;1322   
;;;1323     /* Set SAI Block A source selection value */
;;;1324     tmpreg |= RCC_SAIBlockACLKSource;
000008  ea410100          ORR      r1,r1,r0
;;;1325   
;;;1326     /* Store the new value */
;;;1327     RCC->DCKCFGR = tmpreg;
00000c  6011              STR      r1,[r2,#0]
;;;1328   }
00000e  4770              BX       lr
;;;1329   
                          ENDP

                  |L46.16|
                          DCD      0x4002388c

                          AREA ||i.RCC_SAIBlockBCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SAIBlockBCLKConfig PROC
;;;1346     */
;;;1347   void RCC_SAIBlockBCLKConfig(uint32_t RCC_SAIBlockBCLKSource)
000000  4a03              LDR      r2,|L47.16|
;;;1348   {
;;;1349     uint32_t tmpreg = 0;
;;;1350     
;;;1351     /* Check the parameters */
;;;1352     assert_param(IS_RCC_SAIBCLK_SOURCE(RCC_SAIBlockBCLKSource));
;;;1353     
;;;1354     tmpreg = RCC->DCKCFGR;
000002  6811              LDR      r1,[r2,#0]
;;;1355   
;;;1356     /* Clear RCC_DCKCFGR_SAI1BSRC[1:0] bits */
;;;1357     tmpreg &= ~RCC_DCKCFGR_SAI1BSRC;
000004  f4210140          BIC      r1,r1,#0xc00000
;;;1358   
;;;1359     /* Set SAI Block B source selection value */
;;;1360     tmpreg |= RCC_SAIBlockBCLKSource;
000008  ea410100          ORR      r1,r1,r0
;;;1361   
;;;1362     /* Store the new value */
;;;1363     RCC->DCKCFGR = tmpreg;
00000c  6011              STR      r1,[r2,#0]
;;;1364   }
00000e  4770              BX       lr
;;;1365   
                          ENDP

                  |L47.16|
                          DCD      0x4002388c

                          AREA ||i.RCC_SAIPLLI2SClkDivConfig||, CODE, READONLY, ALIGN=2

                  RCC_SAIPLLI2SClkDivConfig PROC
;;;1242     */
;;;1243   void RCC_SAIPLLI2SClkDivConfig(uint32_t RCC_PLLI2SDivQ)  
000000  4a04              LDR      r2,|L48.20|
;;;1244   {
;;;1245     uint32_t tmpreg = 0;
;;;1246     
;;;1247     /* Check the parameters */
;;;1248     assert_param(IS_RCC_PLLI2S_DIVQ_VALUE(RCC_PLLI2SDivQ));
;;;1249     
;;;1250     tmpreg = RCC->DCKCFGR;
000002  6811              LDR      r1,[r2,#0]
;;;1251   
;;;1252     /* Clear PLLI2SDIVQ[4:0] bits */
;;;1253     tmpreg &= ~(RCC_DCKCFGR_PLLI2SDIVQ);
000004  f021011f          BIC      r1,r1,#0x1f
;;;1254   
;;;1255     /* Set PLLI2SDIVQ values */
;;;1256     tmpreg |= (RCC_PLLI2SDivQ - 1);
000008  f1a00001          SUB      r0,r0,#1
00000c  ea410100          ORR      r1,r1,r0
;;;1257   
;;;1258     /* Store the new value */
;;;1259     RCC->DCKCFGR = tmpreg;
000010  6011              STR      r1,[r2,#0]
;;;1260   }
000012  4770              BX       lr
;;;1261   
                          ENDP

                  |L48.20|
                          DCD      0x4002388c

                          AREA ||i.RCC_SAIPLLSAIClkDivConfig||, CODE, READONLY, ALIGN=2

                  RCC_SAIPLLSAIClkDivConfig PROC
;;;1274     */
;;;1275   void RCC_SAIPLLSAIClkDivConfig(uint32_t RCC_PLLSAIDivQ)  
000000  4a04              LDR      r2,|L49.20|
;;;1276   {
;;;1277     uint32_t tmpreg = 0;
;;;1278     
;;;1279     /* Check the parameters */
;;;1280     assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(RCC_PLLSAIDivQ));
;;;1281     
;;;1282     tmpreg = RCC->DCKCFGR;
000002  6811              LDR      r1,[r2,#0]
;;;1283   
;;;1284     /* Clear PLLI2SDIVQ[4:0] and PLLSAIDIVQ[4:0] bits */
;;;1285     tmpreg &= ~(RCC_DCKCFGR_PLLSAIDIVQ);
000004  f42151f8          BIC      r1,r1,#0x1f00
;;;1286   
;;;1287     /* Set PLLSAIDIVQ values */
;;;1288     tmpreg |= ((RCC_PLLSAIDivQ - 1) << 8);
000008  f1a00001          SUB      r0,r0,#1
00000c  ea412000          ORR      r0,r1,r0,LSL #8
;;;1289   
;;;1290     /* Store the new value */
;;;1291     RCC->DCKCFGR = tmpreg;
000010  6010              STR      r0,[r2,#0]
;;;1292   }
000012  4770              BX       lr
;;;1293   
                          ENDP

                  |L49.20|
                          DCD      0x4002388c

                          AREA ||i.RCC_SYSCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SYSCLKConfig PROC
;;;862      */
;;;863    void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
000000  4a03              LDR      r2,|L50.16|
;;;864    {
;;;865      uint32_t tmpreg = 0;
;;;866    
;;;867      /* Check the parameters */
;;;868      assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
;;;869    
;;;870      tmpreg = RCC->CFGR;
000002  6811              LDR      r1,[r2,#0]
;;;871    
;;;872      /* Clear SW[1:0] bits */
;;;873      tmpreg &= ~RCC_CFGR_SW;
000004  f0210103          BIC      r1,r1,#3
;;;874    
;;;875      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;876      tmpreg |= RCC_SYSCLKSource;
000008  ea410100          ORR      r1,r1,r0
;;;877    
;;;878      /* Store the new value */
;;;879      RCC->CFGR = tmpreg;
00000c  6011              STR      r1,[r2,#0]
;;;880    }
00000e  4770              BX       lr
;;;881    
                          ENDP

                  |L50.16|
                          DCD      0x40023808

                          AREA ||i.RCC_TIMCLKPresConfig||, CODE, READONLY, ALIGN=2

                  RCC_TIMCLKPresConfig PROC
;;;1416     */
;;;1417   void RCC_TIMCLKPresConfig(uint32_t RCC_TIMCLKPrescaler)
000000  4901              LDR      r1,|L51.8|
;;;1418   {
;;;1419     /* Check the parameters */
;;;1420     assert_param(IS_RCC_TIMCLK_PRESCALER(RCC_TIMCLKPrescaler));
;;;1421   
;;;1422     *(__IO uint32_t *) DCKCFGR_TIMPRE_BB = RCC_TIMCLKPrescaler;
000002  6008              STR      r0,[r1,#0]
;;;1423     
;;;1424   }
000004  4770              BX       lr
;;;1425   
                          ENDP

000006  0000              DCW      0x0000
                  |L51.8|
                          DCD      0x424711e0

                          AREA ||i.RCC_WaitForHSEStartUp||, CODE, READONLY, ALIGN=1

                  RCC_WaitForHSEStartUp PROC
;;;287      */
;;;288    ErrorStatus RCC_WaitForHSEStartUp(void)
000000  b530              PUSH     {r4,r5,lr}
;;;289    {
;;;290      __IO uint32_t startupcounter = 0;
000002  2400              MOVS     r4,#0
;;;291      ErrorStatus status = ERROR;
;;;292      FlagStatus hsestatus = RESET;
;;;293      /* Wait till HSE is ready and if Time out is reached exit */
;;;294      do
;;;295      {
;;;296        hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
;;;297        startupcounter++;
;;;298      } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
000004  f44f45a0          MOV      r5,#0x5000
                  |L52.8|
000008  2031              MOVS     r0,#0x31              ;296
00000a  f7fffffe          BL       RCC_GetFlagStatus
00000e  1c64              ADDS     r4,r4,#1              ;297
000010  42ac              CMP      r4,r5
000012  d001              BEQ      |L52.24|
000014  2800              CMP      r0,#0
000016  d0f7              BEQ      |L52.8|
                  |L52.24|
;;;299    
;;;300      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
000018  2031              MOVS     r0,#0x31
00001a  f7fffffe          BL       RCC_GetFlagStatus
00001e  b108              CBZ      r0,|L52.36|
;;;301      {
;;;302        status = SUCCESS;
000020  2001              MOVS     r0,#1
;;;303      }
;;;304      else
;;;305      {
;;;306        status = ERROR;
;;;307      }
;;;308      return (status);
;;;309    }
000022  bd30              POP      {r4,r5,pc}
                  |L52.36|
000024  2000              MOVS     r0,#0                 ;306
000026  bd30              POP      {r4,r5,pc}
;;;310    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  APBAHBPrescTable
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  01020304          DCB      0x01,0x02,0x03,0x04
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  06070809          DCB      0x06,0x07,0x08,0x09

;*** Start embedded assembler ***

#line 1 "..\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_rcc.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f4xx_rcc_c_49e27980____REV16|
#line 112 "C:\\Keil\\ARM\\RV31\\Inc\\core_cmInstr.h"
|__asm___15_stm32f4xx_rcc_c_49e27980____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f4xx_rcc_c_49e27980____REVSH|
#line 130
|__asm___15_stm32f4xx_rcc_c_49e27980____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
